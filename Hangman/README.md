# 🧍‍♂️ 행맨 게임
- 배열에 여러 가지 단어를 저장해두고 랜덤으로 한 단어를 선정한다.
- 게임이 시작되면 단어의 글자 수가 주어진다.
- 사용자는 A~Z까지의 알파벳을 입력해서 정답을 유추한다.
- 시도 횟수는 총 5번이며 단어에 포함된 알파벳을 입력 시 시도 횟수는 감소하지 않는다. 만일, 단어에 미포함된 알파벳을 입력했을 땐 시도 횟수가 감소한다.
- 사용자가 공백을 입력했을 때, A~Z 사이의 알파벳을 입력하라는 안내와 함께 재입력 기회를 준다. 이때, 시도 횟수는 감소되지 않는다.
-  정답을 맞히거나 시도 횟수가 모두 소진되면 정답을 알려주고 게임을 종료한다.
<br/>

## 🤔 단어에서 중복된 알파벳의 인덱스 찾기
예를 들어, 단어가 'BANANA'라면 'A'라는 알파벳이 단어에 3개 들어있다.
사용자가 'A'를 입력해서 유추를 성공하면 사용자에게 '_ A _ A _ A' 형태로 출력해 주어야 한다.
<br/>

빈 배열에 단어 길이만큼 `_`(언더바)를 넣어두고 사용자가 입력한 알파벳이 단어에 있으면 인덱스를 찾아 해당 자리에 알파벳을 넣어주는 형식으로 진행했다.
그런데 `.indexOf()`를 사용하니 최초의 'A'가 있는 자리의 인덱스 값만 반환해서 나머지 자리의 인덱스를 찾을 수 없었고, '_ A _ _ _ _' 형태로 출력되었다.
<br/>

**이 문제를 `Lodash`의 `.indexOf()`를 사용하여 해결할 수 있었다.**<br/>
`Lodash`의 `.indexOf()`는 세 번째 인자로 탐색 위치를 지정할 수 있다.
따라서 단어 길이만큼 반복문이 진행될 때, 최초의 'A'의 인덱스를 찾으면 그 다음부터 위치부터 다시 탐색할 수 있도록 `order`의 값을 증가시키는 방식으로 단어에 포함되어 있는 중복된 알파벳의 인덱스를 찾아 모두 배열에 삽입할 수 있었다.

```js
import _ from 'lodash'

if (select_word.includes(input)) {
  for(let i=0; i<select_word.length; i++) {
    answer[_.indexOf(select_word, input, order)] = input
    order = _.indexOf(select_word, input, order) + 1
  }
  order = 0
  answer_string = answer.join(" ")

  alert("'" + input + "' (이)가 존재합니다.\n남은 시도 횟수: " + life + "\n\n" + answer_string)
}
else {
  alert("'" + input + "' (이)가 존재하지 않습니다.\n남은 시도 횟수: " + --life + "\n\n" + answer_string)
}
```
<br/>
  
## 👍 실행 결과
- 정답을 맞힌 경우

![성공](https://user-images.githubusercontent.com/103479942/165788888-dad332c6-b03a-4255-936a-ed7664b04454.gif)

- 정답을 맞히지 못한 경우

![실패](https://user-images.githubusercontent.com/103479942/165789036-65528860-e9bd-44aa-ad3f-f912265f9910.gif)
